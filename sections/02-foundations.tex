\section{Conceptual Foundations of Microservices Architectures}\label{sec:foundations}

\subsection{Microservices and Microservices Architectures}

\subsection{Representational State Transfer (\acs{REST})}

\ac{REST} is an architectural style for network-based applications coined by Fielding~\cite{Fielding2000}.
Webservices and \acp{API} following this style are often referred to as \acs{REST}ful \acp{API}.
According to Fielding, this style focuses ``on the roles of components, the constraints upon their interaction with other components, and their interpretation of significant data elements''.
One of the key aspects of his definition is the word \textit{style}, because \ac{REST} is not a guideline or a standard~\cite{Malakhov2018}.

Typical \ac{REST} interactions consist of a user agent (e.g.\ a web browser) requesting a representation of a resource from a server~\cite{Erenkrantz2007}.
This communication be cached by intermediary proxies before being delivered.
The goal of this architecture is to reduce network latency, while also making the components more independent and scalable.

% confusion
In the past \ac{REST} has become an industry buzzword and is often confused with the notion of using \acs{HTTP}-based \acp{API} in general~\cite{Fielding2017}.
However, while \ac{HTTP} is commonly used together with \ac{REST} \acp{API}, the principles of \ac{REST} propose a set of more high-level constraints.

\subsubsection{REST Principles}

Although \ac{REST} does not provide a concrete set of rules or guidelines, several principles for \ac{REST}ful design exist.

\paragraph{Identifiable Resources}

The key abstraction of \ac{REST} are resources \cite{Fielding2000,Erenkrantz2007}.
Resources can be any information that can be named.
This includes types of information commonly found in the web, such as \acs{HTML}-documents, images, or JavaScript files, but also can mean non-virtual objects (e.g. a person), or temporal services (e.g. today's weather in Bamberg), collections of other resources, and so on.
While resources may change over time, the semantics of the resource must be static.
For example, in the context of a version control system, the resource \textit{latest version} always identifies the latest version, although this resource may change at some point from \textit{version 1.0} to \textit{version 1.1}.
Every resource is identified by a \textit{resource identifier}, e.g. a \ac{URL}. 

\paragraph{Self-descriptive Resources}

Components following the \ac{REST} architectural style communicate by using representations of resources \cite{Fielding2000}.
Representations of resources include some kind of binary data, and metadata describing this data.
In some cases, also metadata describing the metadata is part of the representation.
This separation of resource and representation introduces a layer of indirection between them \cite{Erenkrantz2007}.

\paragraph{Stateless Interaction}

According to Fielding, all \ac{REST} interactions are stateless \cite{Fielding2000}.
While this does not mean that \ac{REST} applications do not deal with state, it requires all requests to contain all the information for processing it to be contained in this request, independant of requests that may have preceeded it.
This allows applications to scale better, as no resources are required to maintain application state at the processing entity, while also allowing for requests to be processed in parallel.
Additionally, it allows for better caching of responses, as intermediaries can fully understand a single request in isolation.

\paragraph{Few Primitive Operations}

\ac{REST} components only support a very limited set of operations per resource \cite{Erenkrantz2007}.
The operations of a resource typically produce a representation of the resource capturing its current or intendet state.
These operations are commonly implemented in practice using \ac{HTTP} methods~(see \autoref{sec:foundations:http}).

\paragraph{Cachability}

Caching is an important concept of \ac{REST}, as it improves the latency between client and server~\cite{Erenkrantz2007,Fielding2000}.
Caches can be used at the client-side to avoid sending network requests when the same resource is requested again, or at the server-side to avoid processing requests mutliple times.
This cachablity in \ac{REST} applications is achieved mainly by idempotency of certain requests.
Idempotency in this case means, that certain requests do not alter the future behaviour of the server.
So for example, if a client requests a resource multiple times, the response of the server does not change.

\paragraph{Transparent Intermediaries}

Between the components of \ac{REST}, intermediaries can be placed that are transparent to both the client and server \cite{Fielding2000}.
These intermediaries can take up different roles, for example cache communication between client and server, restrict access to resources, or modify and augment requests and responses.

\subsubsection{Hypertext Transfer Protocol (\acs{HTTP})}\label{sec:foundations:http}

Commonly, \ac{REST} \acp{API} are implemented on top of \ac{HTTP} for obtaining, creating, modifying, and deleting resources~\cite{Schermann2015}.

\begin{table}[ht]
    \centering
    \begin{tabular}{@{}rcc@{}}
    \toprule
    \textbf{\acs{HTTP} Method}  & \textbf{Idempotent}   & \textbf{Safe} \\ \midrule
    \texttt{GET}                & \checkmark            & \checkmark    \\
    \texttt{HEAD}               & \checkmark            & \checkmark    \\
    \texttt{POST}               &                       &               \\
    \texttt{PUT}                & \checkmark            &               \\ 
    \texttt{DELETE}             & \checkmark            &               \\ 
    \texttt{PATCH}              &                       &               \\ 
    \texttt{OPTIONS}            & \checkmark            & \checkmark    \\ \bottomrule
    \end{tabular}
    \caption{Overview of selected HTTP Methods~\cite{RFC7321}}\label{tab:http-methods}
\end{table}

\begin{lstlisting}[caption={\acs{HTTP} GET request}, showlines=true]
GET /item HTTP/1.1
Host: localhost
Accept: application/json

\end{lstlisting}

\begin{lstlisting}[caption=\acs{HTTP} response to GET request]
HTTP/1.1 200 OK
Server: api-server
Content-Type: application/json

{"title": "Item", "price": 1.99}
\end{lstlisting}

\begin{lstlisting}[caption={\acs{HTTP} PUT request}]
PUT /item HTTP/1.1
Host: localhost
Content-Type: application/json

{"title": "Item", "price": 3.59}
\end{lstlisting}

\begin{lstlisting}[caption={\acs{HTTP} response to PUT request}, showlines=true]
HTTP/1.1 204 No Content
Server: api-server

\end{lstlisting}

\subsubsection{Javascript Object Notation (\acs{JSON})}

\subsubsection{Hypermedia as the Engine of Application State (\acs{HATEOAS})}

\subsection{GraphQL}

\subsubsection{Structure of the Language}

\subsubsection{GraphQL Schemas}

\subsubsection{Tools for GraphQL}