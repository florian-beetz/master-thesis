\section{Conceptual Foundations of Microservice Architectures}\label{sec:foundations}

\subsection{Microservices and Microservice Architectures}

Microservices and Microservice Architectures are a widely adopted architectural style originating from \acp{SOA}~\cite{Mazzara2020}.
In contrast to \ac{SOA}, microservices do not primarily focus on reuse and composition, but on independence, replacability, and autonomy~\cite{Baresi2020}.
Building an application using a microservice architecture describes the approach of decomposing the application into a set of small services (so-called \textit{microservices}), each running in their own process, providing a lightweight way of interacting with each other, often using \ac{HTTP} and \ac{REST}~\cite{Lewis2014}.
One service is responsible for a business capability.
Services can be deployed independantly and in an automated fashion.

Enterprise applications typically consist of a client-side \ac{UI}, a database, and a server-side application~\cite{Lewis2014}.
The server-side application handles user requests, executes domain logic, queries and updates the database, and populates views for the user.
Traditional applications following the monolithic architectural style package this functionality into a single logical executable, such that updates to any parts of the system require rebuilding and redeployment of the whole system.
Structuring this application only happens via language features such as classes, functions, and namespaces.
Horizontally scaling this application requires running multiple instances of the application behind a load-balancer.
While modularization can also be achieved with this monolithic style, microservices make the separation of modules explicit, by running in their own process.
They also allow scaling only the parts of the application requiring more resources.

According to Lewis and Fowler~\cite{Lewis2014}, there is no formal definition of microservice architecture, but common characteristics of the style can be identified.
However, not all microservice architectures will have all the characteristics, but most of them will exhibit most characteristics.

\paragraph{Componentization via Services}

Microservice architectures use services as their primary componentization mechanism~\cite{Lewis2014}.
Componentization via libraries and software modules can be called with in-memory function calls.
This contrasts out-of-process services, where communication is more expensive, as it requires using a mechanism such as web service requests, or \acp{RPC}.
However, this also makes services independantly deployable (see \autoref{fig:ms-componentization:mic}), whereas applications linked to a single executable must be built and deployed as a whole (see \autoref{fig:ms-componentization:mon}).
As a result, this allows better utilizing available resources as the parts of the application experiencing higher load can be horizontally scaled.
Additionally, changes to a service only require this service to be redeployed in most cases, while the rest of the application remains running.
Only changes to the interface of a service may require coordination between multiple services, however, this can also be avoided by cohesive service boundaries and evolution mechanisms in the service contracts.
However, having explicit service contracts requiring remote \ac{API} calls make it harder to breaking encapsulation than in-process function calls.

\begin{figure}[!htb]
    \centering
    \begin{subfigure}{.5\textwidth}
        \centering
        \input{graphics/ms-componentization-mon.tex}
        \caption{Monolith}
        \label{fig:ms-componentization:mon}
    \end{subfigure}%
    \begin{subfigure}{.5\textwidth}
        \centering
        \input{graphics/ms-componentization-mic.tex}
        \caption{Microservice}
        \label{fig:ms-componentization:mic}
    \end{subfigure}
    \caption{Componentization in monolithic and microservice architectures~\cite{Lewis2014}}
    \label{fig:ms-componentization}
\end{figure}

\paragraph{Organized around Business Capabilities}

Often, teams are organized after the architectural layer they are responsible for (\ac{UI} team, backend team, database team)~\cite{Kim2016, Lewis2014}.
Separation along these lines ignores the fact, that these architectural parts are usally tightly coupled and thus, cross-team projects are required to implement even simple changes.
Teams often try to implement logic into the part of the application they have access to, leading to business logic spread out into every part of the application.
This phenomenon is described by Conway's law:

\begin{displayquote}
    Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure.
    \begin{flushright}
        --- \textit{Malvin E. Conway, 1968~\cite{Conway1968}}
    \end{flushright}
\end{displayquote}

When working with microservices, each service usually is developed by one team~\cite{Baresi2020, Mazzara2020, Lewis2014}.
Since services are organized around business capability, the team must have all required skills to develop the service, ranging from project management, over \ac{UI} development, to database development.
While this characteristic can also be applied to monolithic application development, the explicit separation required by microservices make it easier to form such teams.

\paragraph{Products not Projects}

Traditionally, development and operations teams of applications are clearly separated~\cite{Kim2016}.
Once the development of an application is done, it is handed over to an operations team and the developers start working on a different project.
Microservice proponents usually implement a DevOps model of developing and operating an application, where the same team owns a microservice over its whole lifecycle, maintaining and also operating it~\cite{Lewis2014}.
This moves away the focus of a project-based view, where software is seen as a set of functionalities, to a product-based view focusing on the business capabilities.
While this increases the contact developers have with their users, it also removes the organizational overhead of having separated development and operations teams.

\paragraph{Smart Endpoints and Dumb Pipes}

Microservices encapsulate all of the business logic inside of a service~\cite{Lewis2014}.
The communication mechanism is typically lightweight, such as \ac{REST}ful resource \acp{API} or lightweight message queues for asynchronous communication.
This heavily contrasts mechansims used in \ac{SOA}, such as \ac{ESB}, where apart from transportation, middlewares often facilitate routing, service choreography, message transformations, and applying business rules.
Lewis and Fowler~\cite{Lewis2014} name this approach \textit{smart endpoints and dumb pipes}.
It describes the idea, that a microservice should own its domain logic and be as decoupled and cohesive as possible.

\paragraph{Decentralized Governance}



\paragraph{Decentralized Data Management}

\begin{figure}[!htb]
    \centering
    \begin{subfigure}{.5\textwidth}
        \centering
        \input{graphics/ms-data-mon.tex}
        \caption{Monolith}
        \label{fig:sub1}
    \end{subfigure}%
    \begin{subfigure}{.5\textwidth}
        \centering
        \input{graphics/ms-data-mic.tex}
        \caption{Microservice}
        \label{fig:sub2}
    \end{subfigure}
    \caption{Data management in monolithic and microservice architectures~\cite{Lewis2014}}
    \label{fig:test}
\end{figure}

\paragraph{Infrastructure Automation}

\paragraph{Design for Failure}

\paragraph{Evolutionary Design}

\subsection{Representational State Transfer (\acs{REST})}

\ac{REST} is an architectural style for network-based applications coined by Fielding~\cite{Fielding2000}.
Webservices and \acp{API} following this style are often referred to as \acs{REST}ful \acp{API}.
According to Fielding, this style focuses ``on the roles of components, the constraints upon their interaction with other components, and their interpretation of significant data elements''.
One of the key aspects of his definition is the word \textit{style}, because \ac{REST} is not a guideline or a standard~\cite{Malakhov2018}.

Typical \ac{REST} interactions consist of a user agent (e.g.\ a web browser) requesting a representation of a resource from a server~\cite{Erenkrantz2007}.
This communication be cached by intermediary proxies before being delivered.
The goal of this architecture is to reduce network latency, while also making the components more independent and scalable.

% confusion
In the past \ac{REST} has become an industry buzzword and is often confused with the notion of using \acs{HTTP}-based \acp{API} in general~\cite{Fielding2017}.
However, while \ac{HTTP} is commonly used together with \ac{REST} \acp{API}, the principles of \ac{REST} propose a set of more high-level constraints.

\subsubsection{REST Principles}

Although \ac{REST} does not provide a concrete set of rules or guidelines, several principles for \ac{REST}ful design exist.

\paragraph{Identifiable Resources}

The key abstraction of \ac{REST} are resources \cite{Fielding2000,Erenkrantz2007}.
Resources can be any information that can be named.
This includes types of information commonly found in the web, such as \acs{HTML}-documents, images, or JavaScript files, but also can mean non-virtual objects (e.g. a person), or temporal services (e.g. today's weather in Bamberg), collections of other resources, and so on.
While resources may change over time, the semantics of the resource must be static.
For example, in the context of a version control system, the resource \textit{latest version} always identifies the latest version, although this resource may change at some point from \textit{version 1.0} to \textit{version 1.1}.
Every resource is identified by a \textit{resource identifier}, e.g. a \ac{URL}. 

\paragraph{Self-descriptive Resources}

Components following the \ac{REST} architectural style communicate by using representations of resources \cite{Fielding2000}.
Representations of resources include some kind of binary data, and metadata describing this data.
In some cases, also metadata describing the metadata is part of the representation.
This separation of resource and representation introduces a layer of indirection between them \cite{Erenkrantz2007}.

\paragraph{Stateless Interaction}

According to Fielding, all \ac{REST} interactions are stateless \cite{Fielding2000}.
While this does not mean that \ac{REST} applications do not deal with state, it requires all requests to contain all the information for processing it to be contained in this request, independant of requests that may have preceeded it.
This allows applications to scale better, as no resources are required to maintain application state at the processing entity, while also allowing for requests to be processed in parallel.
Additionally, it allows for better caching of responses, as intermediaries can fully understand a single request in isolation.

\paragraph{Few Primitive Operations}

\ac{REST} components only support a very limited set of operations per resource \cite{Erenkrantz2007}.
The operations of a resource typically produce a representation of the resource capturing its current or intendet state.
These operations are commonly implemented in practice using \ac{HTTP} methods~(see \autoref{sec:foundations:http}).

\paragraph{Cachability}

Caching is an important concept of \ac{REST}, as it improves the latency between client and server~\cite{Erenkrantz2007,Fielding2000}.
Caches can be used at the client-side to avoid sending network requests when the same resource is requested again, or at the server-side to avoid processing requests mutliple times.
This cachablity in \ac{REST} applications is achieved mainly by idempotency of certain requests.
Idempotency in this case means, that certain requests do not alter the future behaviour of the server.
So for example, if a client requests a resource multiple times, the response of the server does not change.

\paragraph{Transparent Intermediaries}

Between the components of \ac{REST}, intermediaries can be placed that are transparent to both the client and server \cite{Fielding2000}.
These intermediaries can take up different roles, for example cache communication between client and server, restrict access to resources, or modify and augment requests and responses.

\subsubsection{Hypertext Transfer Protocol (\acs{HTTP})}\label{sec:foundations:http}

Commonly, \ac{REST} \acp{API} are implemented on top of \ac{HTTP} for obtaining, creating, modifying, and deleting resources~\cite{Schermann2015}.
\ac{HTTP} is an application level protocol originally developed in 1990~\cite{RFC2068}.
Since 1997, it's version 1.1 was specified and since 2015, version 2 is available.
However, version 2 is only an alternative to 1.1 and does not make this version obsolete~\cite{RFC7540}.

\ac{HTTP} is a text-based protocol following the request-response scheme~\cite{RFC2068}.
All messages are separated into a header and body.
The header consists of a request or status line, depending on whether the message is a \ac{HTTP} request or response.
Additionally, the header may include one or more header fields.

Every request is made to a resource identified by an \ac{URL}~\cite{RFC2068}.
\ac{HTTP} specifies several so-called methods, that may be supported by a resource.
However, the set of methods is intentially left open-ended to allow extensions for different domains.
Resonses always include a status code in its status line indicating whether the request was successfull.
The status code is a three-digit number the server uses to communicate the state of the result of the request.
\ac{HTTP} defines the semantics of the status code to depend on the first digit of the number.
Codes starting with the digit \textit{1} indicate informational messages, \textit{2} indicates success, \textit{3} indicates redirections, \textit{4} indicates client errors, and \textit{5} indicates server errors.
However, while the specification includes a set of pre-defined status codes, this set is not conclusive and may be extended by implementations.

\autoref{lst:http-get-example} shows the general structure of a \ac{HTTP} request.
Line 1 is the request line indicating that this request is a \texttt{GET} request for the resource \texttt{/item/1} using the \ac{HTTP} version 1.1.
\texttt{GET} has the semantics of retrieving the information available, identified by the \ac{URL} of the request.
The header fields specify the server, the request is made to, and what kind of content the client expects.
The header then is terminated by an empty line and no request body is sent.

\begin{lstlisting}[caption={\acs{HTTP} GET request}, showlines=true, label=lst:http-get-example]
GET /item/1 HTTP/1.1
Host: localhost
Accept: application/json

\end{lstlisting}

A response to the above request could look as shown in \autoref{lst:http-response-example}.
The response indicates that the request was executed successfully with the status \texttt{200}.
The header fields indicate the server, that executed the request, and that it contains a body of 33 bytes that should be interpreted as \ac{JSON}.

\begin{lstlisting}[caption={\acs{HTTP} response to GET request}, label=lst:http-response-example]
HTTP/1.1 200 OK
Server: api-server
Content-Type: application/json
Content-Length: 33

{"title": "Item", "price": 1.99}
\end{lstlisting}

If the client now wants to update the resource requested in the above example, it would send a request as shown in \autoref{lst:http-put-example}.
This request uses the \texttt{PUT} method, which has the semantics of updating or creating the resource located at the given \ac{URL} based on the body of the request.
In this example, the request body contains the same \ac{JSON} representation of an item, but with an updated price.

\begin{lstlisting}[caption={\acs{HTTP} PUT request}, label=lst:http-put-example]
PUT /item/1 HTTP/1.1
Host: localhost
Content-Type: application/json
Content-Length: 33

{"title": "Item", "price": 3.59}
\end{lstlisting}

As already shown in the examples above, \ac{HTTP} defines a set of default methods that may be extended to suit the domain of implementations~\cite{RFC2068}.
\autoref{tab:http-methods} shows \ac{HTTP} methods most commonly implemented in the context of \ac{REST} \acp{API}~\cite{Buelthoff2019}.
\ac{HTTP} additionally specifies the properties \textit{safe} and \textit{idempotent} for methods.
If a method is safe, it should not have any side-effects for the user itself nor for other users.
Idempotent methods may have side-effects, but if a request uses an idempotent method and executed multiple times, the side-effects are the same as if it were just executed once.
Safe methods are important for caching, as intermediaries can infer, that the requested resource does not change as a result of the request.
Idempotency on the other hand is important for fault tolerance.
If a request times out, or the connectivity between client and server is lost, the request can be sent again, without causing unintended side-effects.

\begin{table}[ht]
    \centering
    \begin{tabular}{@{}rlcc@{}}
    \toprule
    \textbf{\acs{HTTP} Method}  & \textbf{Semantics}                    & \textbf{Idempotent}   & \textbf{Safe} \\ \midrule
    \texttt{GET}                & retrievs a resource                   & \checkmark            & \checkmark    \\
%    \texttt{HEAD}               & \checkmark            & \checkmark    \\
    \texttt{PUT}                & updates a resource                    & \checkmark            &               \\ 
    \texttt{DELETE}             & deletes a resource                    & \checkmark            &               \\ 
    \texttt{POST}               & \textit{dependant on implementation}  &                       &               \\
%    \texttt{PATCH}              &                       &               \\ 
%    \texttt{OPTIONS}            & \checkmark            & \checkmark    \\
    \bottomrule
    \end{tabular}
    \caption{Overview of selected HTTP Methods~\cite{RFC7321}}\label{tab:http-methods}
\end{table}

As shown in \autoref{tab:http-methods}, \texttt{POST} is a special method, as its semantics are mostly dependand on the implementation of the server~\cite{RFC2068}.
In practice, it is commonly used to implement \ac{RPC} style \acp{API} or to create new resources, for which their \acp{URL} are determined by the server after creation.

\subsubsection{Javascript Object Notation (\acs{JSON})}

\subsubsection{Hypermedia as the Engine of Application State (\acs{HATEOAS})}

\subsection{GraphQL}

\subsubsection{Structure of the Language}

\subsubsection{GraphQL Schemas}

\subsubsection{Tools for GraphQL}