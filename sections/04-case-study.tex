\section{Case Study}\label{sec:case-study}

\subsection{Case Study Design}

In order to identify the architectural differences between implementations of microservice architectures implemented with REST and GraphQL interfaces, a case study is performed.
To be independant of past design decisisions, the case study is performed on a newly implemented example project.

The example project implements the setting of an online shop as shown in \autoref{fig:cs-setting}.
The shop keeps its inventory in one or more warehouses.
When the user orders items from the shop, the inventory is checked and the ordered items are reserved.
When the user's bank processes the payment to the shop, the reserved items of the order are shipped to the user.
For this case study, the user's payment instruction to their bank and the bank's processing of the payment is outside of the scope.

\begin{figure}[!htb]
    \centering
    \input{graphics/use-case.tex}
    \caption{Setting of the Case-Study}
    \label{fig:cs-setting}
\end{figure}

In the first step of the case study, this setting is implemented twice with a microservice architecture, first using \ac{REST} and then using GraphQL.
After implementing the case study, the architecture of both implementations is compared.
At this point, a service cut was intentionally not defined to evaluate if the different technologies also suit a different service cut.

Using both implementations of this scenario, the performance can be compared.
This can be done by defining a set of request scenarios (e.g. a user orders 5 items and pays immediatly afterwards).
The resulting load on the system can then be measured in two different ways.
First, the average response time until a user's request is executed can be measured.
This is important as a fast processing of requests is essential to a user's experience of using the system.
Second, the generated load on the internal network connecting the microservices can be measured.
While this case study only utilizes a single network, for geographically distributed microservices, the network can be a bottleneck.

The last part of the case study is to evaluate a schema evolution of the data helt by the microservices.
This step consists of introducing the additional constraint, that the shipping cost of an order is now dependant on the weight of the items.
This means, that each item now has an additional property, which is consumed within the system.

\subsection{Implementation of \acs{REST} Microservices}

To implement the case study using a \ac{REST} \ac{API} for communication between the microservices, a service cut consisting of four different services was chosen.

\paragraph{Inventory Service}

The inventory service manages the available \textit{items}, and where they are stored.
It maintains a set of \textit{warehouses} where items are located.
Items and warehouses are associated with each other by \textit{stock positions}.
While the items themselves maintain only information such as name or price, stock positions maintain how many of one item is stored in a warehouse.
Additionally, each stock position stores how many of an item in the warehouse is available.
In this case, an item is available, if it is not yet part of an existing order.

\paragraph{Order Service}

The order service accepts user's \textit{orders}.
When a new order is created, the service first verifies that for each \textit{position of the order} enough items are in stock to fulfill the order.
This is done by requesting the stock positions of the items from the inventory service.
If enough items are available, the items are reserved (marked as unavailable).
Next, the shipping service is contacted to calculate the shipping cost for the order and to create a new shipment.
The total of the order is calculated and the payment service is instructed to create a payment with the calculated sum.
The order service is the main service, users interact with.
Apart from that, it provides endpoints to the other services to update the status of the order (i.e. \textit{payment received} or \textit{shipped}).

\paragraph{Shipping Service}

The shipping service manages \textit{shipments} for orders.
In this case study, it only caclulates the cost of shipping for an order.
In a real world implementation, this service could additionally interface with third-party \acp{API} of postal services and print labels for the packages.

\paragraph{Payment Service}

The payment service manages \textit{payments} for orders.
Similarly to the shipping service, this service only stores the due amount, but could interface with payment processors in an real world setting.


A complete overview of the interaction of the services is shown in \autoref{fig:interaction}.
The user creates a new order~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {1}}}, the order service checks if enough items are in stock~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {2}}} and reserves the items if they are~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {3}}}.
Then, a new shipment is created by the shipping service~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {4}}} and a new payment is created by the payment service~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {5}}}.
When the payment is received~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {6}}}, the order is updated~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {7}}} and the shipping service is instructed to ship it~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {8}}}.
Finally, the items are booked out from the inventory~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {9}}}.

\begin{figure}[!htb]
    \centering
    \input{graphics/interaction.tex}
    \caption{Service Interactions}
    \label{fig:interaction}
\end{figure}

\subsubsection{Technology Stack}

Each \acs{REST} microservice was implemented using the general-purpose programming language Java, and the Spring framework\footnote{\url{https://spring.io}}.
Findings of Schermann~\cite{Schermann2015} show, that Java is the most commonly used programming language for microservices.
Spring is a widely used framework for enterprise applications.
According to Snyk's annual \acs{JVM} Ecosystem Report~\cite{Vermeer2020}, 6 out of 10 \acs{JVM} developers use the Spring framework.
Spring is a modular, open source framework consisting of a set of library providing for example dependency injection, data access, a server-side web framework, or cloud integration.

Each of the services is packaged as a Docker\footnote{\url{https://www.docker.com/}} Linux container.
These containers allow to easily distribute the packaged service and simplify the creation of replicas.
The containers for the microservices expose a port to accept \ac{HTTP} requests, that will be handled by the Spring framework.
However, each container is assigned its own IP address, which makes scaling difficult, as the destination for requests needs to be known beforehand.
Thus, an additional container running Traefik is placed before the microservice containers.
Traefik\footnote{\url{https://containo.us/traefik/}} is a reverse proxy and load balancer designed for microservices and has various integrations with different kinds of infrastructure, such as Docker or Kubernetes.

The microservices use the PostgreSQL\footnote{\url{https://www.postgresql.org/}} database system for data storage.
However, multiple instances of the same microservice share just one instance of an containerized database.
In a real-world deployment, the database should not be containerized at all, but rather a distributed database cluster should be used, to achieve high availability, redundancy, and high performance.
Communication with the database is implemented using the Spring Data \acs{JPA}, which provides convinient access to \ac{JPA} data sources.

\begin{figure}[!htb]
    \centering
    \input{graphics/rest-containers.tex}
    \caption{Containers for the \acs{REST} Microservice Architecture}
    \label{fig:rest-containers}
\end{figure}

A deployment with two Order microservices is shown examplary in \autoref{fig:rest-containers}.
Traefik accepts all \ac{HTTP} requests --- regardless wheather they come directly from users, or from other microservices --- and routes them to the appropriate microservice depending on the so-called context path.
The context path specifies a path prefix in the request \ac{URL} and Traefik can be configured to route certain prefixes to certain types of services.
This configuration happens through labels on Docker containers, which can be used to apply metadata to them.


\begin{lstlisting}[caption={Traefik Configuration for the Inventory Service}, showlines=true, label=lst:traefik-docker, language=yaml]
labels:
  - "traefik.enable=true"
  - "traefik.http.routers.inventory.rule=PathPrefix(`/inventory/`)"
  - "traefik.http.routers.inventory.entrypoints=web"
\end{lstlisting}

\autoref{lst:traefik-docker} shows an excerpt of the configuration of the labels for the inventory service.
The labels configure Traefik to route all requests on the \texttt{web} entrypoint with the path prefix \texttt{/inventory/} to this service.
Entrypoints can be configured at Traefik's startup and specify on which port Traefik should listen and can also be configured with different options.
For example, an endpoint could be configured to terminate \ac{TLS} connections and forward the requests without encryption to the appropriate backend service.

\subsubsection{\acs{API} Style}

\begin{itemize}
    \item \acs{HAL}+\acs{JSON} to communicate
    \item All resources provide a link with \texttt{self} relation instead of IDs
    \item The number of \acp{URL} that need to be constructed is intentionally left very small (only resource creation)
    \item Status updates are based on \texttt{PUT}'ing a status resource
\end{itemize}

\subsubsection{OpenAPI Specification and Swagger UI}

\begin{itemize}
    \item OpenAPI is a standard for specifications of REST APIs
    \item Spring provides means to automatically generate the specifications from the controllers
    \item Specification is useful for testing APIs with Swagger UI and can be used to generate clients from it
\end{itemize}

\subsubsection{Client Authentication}

\begin{itemize}
    \item OIDC via Keycloak
    \item explain how OIDC works and why it is a good choice for microservices
    \item Service-to-Service communication is also authenticated via Service Accounts
\end{itemize}

\subsubsection{Service-to-Service Communication}

\begin{itemize}
    \item Code-generation for OpenAPI specifications are available
    \item Clients were implemented by hand because of the higher control and because Spring provides an automated mechanism to authenticate client requests
    \item Different clients for each service, scoped to the required functionality
\end{itemize}

\subsubsection{Optimistic Locking for Write-Operations using \acs{HTTP}}

When using \ac{REST} with the stateless protocol \ac{HTTP}, the problem of handling concurrent modifications to a resource arises.
When users try to update a resource at the same time, the update of the first user is overwritten.
This problem is shown in \autoref{fig:lost-update}, where two clients send \ac{HTTP} \texttt{PUT} requests to the same resource.
The server processes the first update and returns a response indicating that the resource was sucessfully updated.
Meanwhile, an update request of the second client is received and the changes of the other client are overwritten.

\begin{figure}[!htb]
    \centering
    \input{graphics/lost-update.tex}
    \caption{Lost Update Problem}
    \label{fig:lost-update}
\end{figure}

To solve this problem, a locking mechanism needs to be implemented.
However, both \ac{HTTP} and \ac{REST} mandate statelessnes of the communication.
Thus, a optimistic locking procedure must be implemented to comply with these restrictions.
\ac{HTTP} provides several ways of implementing optimistic locking procedures using so-called conditional requests~\cite{MDN2020}.
Conditional requests include a condition that is evaluated by the server and only if this condition holds, the request is executed.
This kind of request is realized with the \ac{HTTP} headers \texttt{If-Match} or \texttt{If-None-Match} that indicate that the requested resource should have or respectively not have a specified hash value provided by the server using the \texttt{ETag} (Entity Tag) header.
Alternatively, \texttt{If-Modified-Since} or \texttt{If-Unmodified-Since} can be used, to indicate that the request should only be executed if the resource was or was not modified since a given point in time.

For the case study, the approach of implementing locking using \texttt{ETag}s and sending requests with \texttt{If-Match} was implemented because the time based conditional requests only be support a granularity of seconds.
If multiple requests are made within the same second, the lost update problem still persists.
\autoref{lst:locking-response} shows the response to a \texttt{GET} request to an updatable resource.
Notably, the response contains an \texttt{ETag} header.

\begin{lstlisting}[caption={Response to \texttt{GET} Requests for Updatable Resources}, showlines=true, label=lst:locking-response, language=http]
[*HTTP/1.1 200 OK*]
Content-Type: application/json
(*\textit{\textbf{ETag}: 12345}*)

{"title": "Item", "price": 1.99}
\end{lstlisting}

If this resource is to be updated, \texttt{PUT} requests must include the \texttt{If-Match} header as shwon in \autoref{lst:locking-request}.
Otherwise, the server will respond with the \texttt{428 Precondition Required} status and not execute the request.
Only if the provided entity tag matches the resource currently stored at the server, the request is updated.
Whenever the entity tag does not match, the server responds with the status code \texttt{412 Precondition Failed}.

\begin{lstlisting}[caption={Request to Update Resources}, showlines=true, label=lst:locking-request, language=http]
[*PUT /item/1 HTTP/1.1*]
Content-Type: application/json
(*\textit{\textbf{If-Match}: 12345}*)

{"title": "Item", "price": 2.49}
\end{lstlisting}

\subsection{Implementation of GraphQL Microservices}

\subsubsection{Technology Stack}

Similar to the \ac{REST} implementation of the microservices, Java and the Spring framework were used for the GraphQL microservices.
To implement the GraphQL interfaces, third-party modules for the Spring framework were used.
The \textit{GraphQL Spring Boot Starter}\footnote{\url{https://github.com/graphql-java-kickstart/graphql-spring-boot}} automatically configures an GraphQL endpoint and sets up GraphiQL.
Federating the schemas of the microservices is achived using the \textit{Appollo Federation on the \acs{JVM}}\footnote{\url{https://github.com/apollographql/federation-jvm}} module.

The individual microservices are packaged as Docker Linux containers and a Traefik reverse proxy is placed before the network interfaces of the containers.
Each of the services provides its own GraphQL endpoint that can process queries requesting objects the service owns, e.g.~the inventory service can process queries about items and where they are stored.
However, to be able to query data from multiple services in one request, a federation gateway is needed.
This allows for example to query the names of all items in an order, where the order microservice and the inventory microservice would be involved.
The gateway is implemented as a Node.js application using the Apollo stack\footnote{\url{https://www.apollographql.com/}}.

\begin{figure}[!htb]
    \centering
    \input{graphics/graphql-containers.tex}
    \caption{Containers for the GraphQL Microservice Architecture}
    \label{fig:graphql-containers}
\end{figure}

\autoref{fig:graphql-containers} shows the same deployment with two deployed order microservices for the GraphQL implementation.
The gateway and the reverse proxy are intertwined, because both the gateway and the microservices should be able to be scaled horizontally.
This requires that the external requests to the gateway, the requests of the gateway to the microservices, and the requests of the microservices to the gateway are all routed through the reverse proxy.

\subsubsection{\acs{API} Style}

\begin{enumerate}
    \item API exposes a single endpoint where all requests are made to
    \item API has more of a resource-API for queries but is completely RPC-based for mutations
    \item Entities are identified by an ID that they expose to clients
\end{enumerate}

\subsubsection{GraphQL Federation Gateway}

\begin{lstlisting}[caption={Schema Definition to Enable Federation}, language=graphqls]
type Item @key(fields: "id") {
    # [...]
}
\end{lstlisting}

\begin{lstlisting}[caption={Implementation of the GraphQL Gateway}, language=javascript]
const gateway = new ApolloGateway({
    serviceList: [
        { name: 'inventory', url: inventoryHost },
        // [...]
    ]
});
const server = new ApolloServer({ gateway });
server.listen();
\end{lstlisting}

\begin{itemize}
    \item Federation allows multiple schemas to be combined to one big one
    \item Individual schemas expose extra information on what additional information a service can provide to an object it does not own and how to identify objects of services it does not own
    \item A gateway is required to combine the schemas, generate query plans upon requests and dispatch sub-queries to the services
\end{itemize}

\subsubsection{Data Fetching}

\begin{lstlisting}[caption={Data Fetching in \acs{API} Models}, language=java]
public class Item {
    private final long id; // [...]
    private final Supplier<Long> totalInStockSupplier;

    public Item(long id, // [...]
                Supplier<Long> totalInStockSupplier) {
        this.id = id; // [...]
        this.totalInStockSupplier = totalInStockSupplier;
    }
    // [...]
    public List<ItemStock> getStock(Integer page, Integer size) {
        return itemStockSupplier.apply(page, size);
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={\acs{API} Model Creation with Fetcher Injection}, language=java]
public class ItemService {
    @Autowired private ItemRepository itemRepository;
    @Autowired private ItemStockService itemStockService;
    // [...]
    public Item lookupItem(long id) {
        return itemRepository.findById(id)
                             .map(this::fromEntity)
                             .orElse(null);
    }
    // [...]
    Item fromEntity(ItemEntity entity) {
        return new Item(
                entity.getId(), // [...]
                () -> itemStockService.lookupTotalInStock(entity.getId())
        );
    }
    // [...]
}
\end{lstlisting}

\begin{itemize}
    \item Complex data fetching, because responses are highly customizable by the user
    \item Data fetching needs to respect eventualities without requesting large amounts of data from the database that the user did not request
\end{itemize}

\subsubsection{GraphiQL and GraphQL Playground}

\begin{itemize}
    \item GraphiQL is a simple web editor for GraphQL queries
    \item GraphQL Playground is more advanced and is used at the gateway
\end{itemize}

\subsubsection{Client Authentication}

\begin{itemize}
    \item Also OICD using Keycloak was used
    \item Authentication can be done on a much granular level -> some clients are not allowed to read certain fields of an entity
\end{itemize}

\subsubsection{Service-to-Service communication}

\begin{itemize}
    \item Code for serializing requests and parsing responses was generated
    \item Transport mechanism was intentionally done by hand, as it allows to easily inject authentication
    \item Means to generate full clients exist
\end{itemize}

\subsection{Architectural Differences of the Implementations}

\subsubsection{\acs{HTTP} Interface}

GraphQL only has one single endpoint, whereas REST specifies the action to execute through an endpint.

\subsubsection{\acs{API} Paradigms}

REST implementation hides the fact that a complex, service-spanning operation is triggered upon status update.
A generic request is made to update a resource for REST, whereas GraphQL makes it explicit, that an action is to be executed on the server.

\subsubsection{Authentication and Authorization}

Authentication is the same, authorization can be easily implemented on a very granular level.
Implementing the same for REST is possible, but requires much more effort.

\subsection{Performance Comparison}

\textbf{To do}

\subsection{Schema Evolution}

\textbf{To do}

\subsection{Discussion}

\textbf{To do}