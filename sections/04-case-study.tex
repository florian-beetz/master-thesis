\section{Case Study}\label{sec:case-study}

\subsection{Case Study Design}

In order to identify the architectural differences between implementations of microservice architectures implemented with REST and GraphQL interfaces, a case study is performed.
To be independant of past design decisisions, the case study is performed on a newly implemented example project.

The example project implements the setting of an online shop as shown in \autoref{fig:cs-setting}.
The shop keeps its inventory in one or more warehouses.
When the user orders items from the shop, the inventory is checked and the ordered items are reserved.
When the user's bank processes the payment to the shop, the reserved items of the order are shipped to the user.
For this case study, the user's payment instruction to their bank and the bank's processing of the payment is outside of the scope.

\begin{figure}[!htb]
    \centering
    \input{graphics/use-case.tex}
    \caption{Setting of the Case-Study}
    \label{fig:cs-setting}
\end{figure}

In the first step of the case study, this setting is implemented twice with a microservice architecture, first using \ac{REST} and then using GraphQL.
After implementing the case study, the architecture of both implementations is compared.
At this point, a service cut was intentionally not defined to evaluate if the different technologies also suit a different service cut.

Using both implementations of this scenario, the performance can be compared.
This can be done by defining a set of request scenarios (e.g. a user orders 5 items and pays immediatly afterwards).
The resulting load on the system can then be measured in two different ways.
First, the average response time until a user's request is executed can be measured.
This is important as a fast processing of requests is essential to a user's experience of using the system.
Second, the generated load on the internal network connecting the microservices can be measured.
While this case study only utilizes a single network, for geographically distributed microservices, the network can be a bottleneck.

The last part of the case study is to evaluate a schema evolution of the data helt by the microservices.
This step consists of introducing the additional constraint, that the shipping cost of an order is now dependant on the weight of the items.
This means, that each item now has an additional property, which is consumed within the system.

\subsection{Implementation of \acs{REST} Microservices}

To implement the case study using a \ac{REST} \ac{API} for communication between the microservices, a service cut consisting of four different services was chosen.

\paragraph{Inventory Service}

The inventory service manages the available \textit{items}, and where they are stored.
It maintains a set of \textit{warehouses} where items are located.
Items and warehouses are associated with each other by \textit{stock positions}.
While the items themselves maintain only information such as name or price, stock positions maintain how many of one item is stored in a warehouse.
Additionally, each stock position stores how many of an item in the warehouse is available.
In this case, an item is available, if it is not yet part of an existing order.

\paragraph{Order Service}

The order service accepts user's \textit{orders}.
When a new order is created, the service first verifies that for each \textit{position of the order} enough items are in stock to fulfill the order.
This is done by requesting the stock positions of the items from the inventory service.
If enough items are available, the items are reserved (marked as unavailable).
Next, the shipping service is contacted to calculate the shipping cost for the order and to create a new shipment.
The total of the order is calculated and the payment service is instructed to create a payment with the calculated sum.
The order service is the main service, users interact with.
Apart from that, it provides endpoints to the other services to update the status of the order (i.e. \textit{payment received} or \textit{shipped}).

\paragraph{Shipping Service}

The shipping service manages \textit{shipments} for orders.
In this case study, it only caclulates the cost of shipping for an order.
In a real world implementation, this service could additionally interface with third-party \acp{API} of postal services and print labels for the packages.

\paragraph{Payment Service}

The payment service manages \textit{payments} for orders.
Similarly to the shipping service, this service only stores the due amount, but could interface with payment processors in an real world setting.


A complete overview of the interaction of the services is shown in \autoref{fig:interaction}.
The user creates a new order~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {1}}}, the order service checks if enough items are in stock~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {2}}} and reserves the items if they are~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {3}}}.
Then, a new shipment is created by the shipping service~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {4}}} and a new payment is created by the payment service~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {5}}}.
When the payment is received~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {6}}}, the order is updated~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {7}}} and the shipping service is instructed to ship it~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {8}}}.
Finally, the items are booked out from the inventory~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {9}}}.

\begin{figure}[!htb]
    \centering
    \input{graphics/interaction.tex}
    \caption{Service Interactions}
    \label{fig:interaction}
\end{figure}

\subsubsection{Optimistic Locking for Write-Operations using \acs{HTTP}}

When using \ac{REST} with the stateless protocol \ac{HTTP}, the problem of handling concurrent modifications to a resource arises.
When users try to update a resource at the same time, the update of the first user is overwritten.
This problem is shown in \autoref{fig:lost-update}, where two clients send \ac{HTTP} \texttt{PUT} requests to the same resource.
The server processes the first update and returns a response indicating that the resource was sucessfully updated.
Meanwhile, an update request of the second client is received and the changes of the other client are overwritten.

\begin{figure}[!htb]
    \centering
    \input{graphics/lost-update.tex}
    \caption{Lost Update Problem}
    \label{fig:lost-update}
\end{figure}

To solve this problem, a locking mechanism needs to be implemented.
However, both \ac{HTTP} and \ac{REST} mandate statelessnes of the communication.
Thus, a optimistic locking procedure must be implemented to comply with these restrictions.
\ac{HTTP} provides several ways of implementing optimistic locking procedures using so-called conditional requests~\cite{MDN2020}.
Conditional requests include a condition that is evaluated by the server and only if this condition holds, the request is executed.
This kind of request is realized with the \ac{HTTP} headers \texttt{If-Match} or \texttt{If-None-Match} that indicate that the requested resource should have or respectively not have a specified hash value provided by the server using the \texttt{ETag} (Entity Tag) header.
Alternatively, \texttt{If-Modified-Since} or \texttt{If-Unmodified-Since} can be used, to indicate that the request should only be executed if the resource was or was not modified since a given point in time.

For the case study, the approach of implementing locking using \texttt{ETag}s and sending requests with \texttt{If-Match} was implemented because the time based conditional requests only be support a granularity of seconds.
If multiple requests are made within the same second, the lost update problem still persists.
\autoref{lst:locking-response} shows the response to a \texttt{GET} request to an updatable resource.
Notably, the response contains an \texttt{ETag} header.

\begin{lstlisting}[caption={Response to \texttt{GET} requests for updatable resources}, showlines=true, label=lst:locking-response]
HTTP/1.1 200 OK
Content-Type: application/json
(*\bfseries{ETag: 12345}*)

{"title": "Item", "price": 1.99}
\end{lstlisting}

If this resource is to be updated, \texttt{PUT} requests must include the \texttt{If-Match} header as shwon in \autoref{lst:locking-request}.
Otherwise, the server will respond with the \texttt{428 Precondition Required} status and not execute the request.
Only if the provided entity tag matches the resource currently stored at the server, the request is updated.
Whenever the entity tag does not match, the server responds with the status code \texttt{412 Precondition Failed}.

\begin{lstlisting}[caption={Request to update resources}, showlines=true, label=lst:locking-request]
PUT /item/1 HTTP/1.1
Content-Type: application/json
(*\bfseries{If-Match: 12345}*)

{"title": "Item", "price": 2.49}
\end{lstlisting}

\subsection{Implementation of GraphQL Microservices}

\subsection{Architectural Differences of the Implementations}

\subsection{Performance Comparison}

\subsection{Schema Evolution}

\subsection{Discussion}