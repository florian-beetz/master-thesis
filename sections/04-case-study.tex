\section{Case Study}\label{sec:case-study}

\subsection{Case Study Design}

In order to identify the architectural differences between implementations of microservice architectures implemented with REST and GraphQL interfaces, a case study is performed.
To be independant of past design decisisions, the case study is performed on a newly implemented example project.

The example project implements the setting of an online shop as shown in \autoref{fig:cs-setting}.
The shop keeps its inventory in one or more warehouses.
When the user orders items from the shop, the inventory is checked and the ordered items are reserved.
When the user's bank processes the payment to the shop, the reserved items of the order are shipped to the user.
For this case study, the user's payment instruction to their bank and the bank's processing of the payment is outside of the scope.

\begin{figure}[!htb]
    \centering
    \input{graphics/use-case.tex}
    \caption{Setting of the Case-Study}
    \label{fig:cs-setting}
\end{figure}

In the first step of the case study, this setting is implemented twice with a microservice architecture, first using \ac{REST} and then using GraphQL.
After implementing the case study, the architecture of both implementations is compared.
At this point, a service cut was intentionally not defined to evaluate if the different technologies also suit a different service cut.

Using both implementations of this scenario, the performance can be compared.
This can be done by defining a set of request scenarios (e.g. a user orders 5 items and pays immediatly afterwards).
The resulting load on the system can then be measured in two different ways.
First, the average response time until a user's request is executed can be measured.
This is important as a fast processing of requests is essential to a user's experience of using the system.
Second, the generated load on the internal network connecting the microservices can be measured.
While this case study only utilizes a single network, for geographically distributed microservices, the network can be a bottleneck.

The last part of the case study is to evaluate a schema evolution of the data helt by the microservices.
This step consists of introducing the additional constraint, that the shipping cost of an order is now dependant on the weight of the items.
This means, that each item now has an additional property, which is consumed within the system.

\subsection{Implementation}

\subsubsection{\acs{REST}}

To evaluate the architectural differences between implementing a microservice architecture with REST and GraphQL interfaces, a case study was performed.
The case study implements an online shopping scenario, where users can place orders with multiple items~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {1}}}.
When new orders are received, the inventory is checked~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {2}}} if the items are available and then reserved for the user~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {3}}}.
Additionally, the shipping cost is calculated~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {4}}}.
When a payment is received from an external payment provider~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {5}}}, the total of the order is checked~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {6}}} and if the payment suffices, the order is marked ready for shipping~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {7}}}~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {8}}} and the reserved items can be booked out~\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {9}}}.
This process is shown in \autoref{fig:interaction}.

\begin{figure}[!htb]
    \centering
    \input{graphics/interaction.tex}
    \caption{Service Interactions}
    \label{fig:interaction}
\end{figure}

\paragraph{Optimistic Locking for Updates}

When using \ac{REST} with the stateless protocol \ac{HTTP}, the problem of handling concurrent modifications to a resource arises.
When users try to update a resource at the same time, the update of the first user is overwritten.
This problem is shown in \autoref{fig:lost-update}, where two clients send \ac{HTTP} \texttt{PUT} requests to the same resource.
The server processes the first update and returns a response indicating that the resource was sucessfully updated.
Meanwhile, an update request of the second client is received and the changes of the other client are overwritten.

\begin{figure}[!htb]
    \centering
    \input{graphics/lost-update.tex}
    \caption{Lost Update Problem}
    \label{fig:lost-update}
\end{figure}

To solve this problem, a locking mechanism needs to be implemented.
However, both \ac{HTTP} and \ac{REST} mandate statelessnes of the communication.
Thus, a optimistic locking procedure must be implemented to comply with these restrictions.
\ac{HTTP} provides several ways of implementing optimistic locking procedures using so-called conditional requests~\cite{MDN2020}.
Conditional requests include a condition that is evaluated by the server and only if this condition holds, the request is executed.
This kind of request is realized with the \ac{HTTP} headers \texttt{If-Match} or \texttt{If-None-Match} that indicate that the requested resource should have or respectively not have a specified hash value provided by the server using the \texttt{ETag} (Entity Tag) header.
Alternatively, \texttt{If-Modified-Since} or \texttt{If-Unmodified-Since} can be used, to indicate that the request should only be executed if the resource was or was not modified since a given point in time.

For the case study, the approach of implementing locking using \texttt{ETag}s and sending requests with \texttt{If-Match} was implemented because the time based conditional requests only be support a granularity of seconds.
If multiple requests are made within the same second, the lost update problem still persists.
\autoref{lst:locking-response} shows the response to a \texttt{GET} request to an updatable resource.
Notably, the response contains an \texttt{ETag} header.

\begin{lstlisting}[caption={Response to \texttt{GET} requests for updatable resources}, showlines=true, label=lst:locking-response]
HTTP/1.1 200 OK
Content-Type: application/json
(*\bfseries{ETag: 12345}*)

{"title": "Item", "price": 1.99}
\end{lstlisting}

If this resource is to be updated, \texttt{PUT} requests must include the \texttt{If-Match} header as shwon in \autoref{lst:locking-request}.
Otherwise, the server will respond with the \texttt{428 Precondition Required} status and not execute the request.
Only if the provided entity tag matches the resource currently stored at the server, the request is updated.
Whenever the entity tag does not match, the server responds with the status code \texttt{412 Precondition Failed}.

\begin{lstlisting}[caption={Request to update resources}, showlines=true, label=lst:locking-request]
PUT /item/1 HTTP/1.1
Content-Type: application/json
(*\bfseries{If-Match: 12345}*)

{"title": "Item", "price": 2.49}
\end{lstlisting}

\subsection{Architectural Differences of the Implementations}

\subsection{Performance Comparison}

\subsection{Schema Evolution}

\subsection{Discussion}